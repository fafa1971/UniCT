======================================================================
                           GRAPH UNIT NOTES
======================================================================

The first part of this file contains the interface section of the
Graph unit. The second part of this file contains corrections and
additions to the Graph unit material in the Owner's Handbook.


{*********************************************************}
{                                                         }
{       Turbo Pascal Version 4.0                          }
{       GRAPH Unit Interface Documentation                }
{                                                         }
{       Copyright (c) 1987 by Borland International, Inc. }
{                                                         }
{*********************************************************}

{$D-,R-,S-}

unit Graph;

interface

const
  { GraphResult error return codes: }
  grOk               =   0;
  grNoInitGraph      =  -1;
  grNotDetected      =  -2;
  grFileNotFound     =  -3;
  grInvalidDriver    =  -4;
  grNoLoadMem        =  -5;
  grNoScanMem        =  -6;
  grNoFloodMem       =  -7;
  grFontNotFound     =  -8;
  grNoFontMem        =  -9;
  grInvalidMode      = -10;
  grError            = -11;   { generic error }
  grIOerror          = -12;
  grInvalidFont      = -13;
  grInvalidFontNum   = -14;
  grInvalidDeviceNum = -15;

  { define graphics drivers }
  Detect   = 0;    { requests autodetection }
  CGA      = 1;
  MCGA     = 2;
  EGA      = 3;
  EGA64    = 4;
  EGAMono  = 5;
  RESERVED = 6;
  HercMono = 7;
  ATT400   = 8;
  VGA      = 9;
  PC3270   = 10;

  { graphics modes for each driver }
  CGAC0      = 0;  { 320x200 palette 0: LightGreen, LightRed, Yellow; 1 page }
  CGAC1      = 1;  { 320x200 palette 1: LightCyan, LightMagenta, White; 1 page }
  CGAC2      = 2;  { 320x200 palette 2: Green, Red, Brown; 1 page }
  CGAC3      = 3;  { 320x200 palette 3: Cyan, Magenta, LightGray; 1 page }
  CGAHi      = 4;  { 640x200 1 page }
  MCGAC0     = 0;  { 320x200 palette 0: LightGreen, LightRed, Yellow; 1 page }
  MCGAC1     = 1;  { 320x200 palette 1: LightCyan, LightMagenta, White; 1 page }
  MCGAC2     = 2;  { 320x200 palette 2: Green, Red, Brown; 1 page }
  MCGAC3     = 3;  { 320x200 palette 3: Cyan, Magenta, LightGray; 1 page }
  MCGAMed    = 4;  { 640x200 1 page }
  MCGAHi     = 5;  { 640x480 1 page }
  EGALo      = 0;  { 640x200 16 color 4 page }
  EGAHi      = 1;  { 640x350 16 color 2 page }
  EGA64Lo    = 0;  { 640x200 16 color 1 page }
  EGA64Hi    = 1;  { 640x350 4 color  1 page }
  EGAMonoHi  = 3;  { 640x350 64K on card, 1 page; 256K on card, 2 page }
  HercMonoHi = 0;  { 720x348 2 page }
  ATT400C0   = 0;  { 320x200 palette 0: LightGreen, LightRed, Yellow; 1 page }
  ATT400C1   = 1;  { 320x200 palette 1: LightCyan, LightMagenta, White; 1 page }
  ATT400C2   = 2;  { 320x200 palette 2: Green, Red, Brown; 1 page }
  ATT400C3   = 3;  { 320x200 palette 3: Cyan, Magenta, LightGray; 1 page }
  ATT400Med  = 4;  { 640x200 1 page }
  ATT400Hi   = 5;  { 640x400 1 page }
  VGALo      = 0;  { 640x200 16 color 4 page }
  VGAMed     = 1;  { 640x350 16 color 2 page }
  VGAHi      = 2;  { 640x480 16 color 1 page }
  PC3270Hi   = 0;  { 720x350 1 page }

  { Colors for SetPalette and SetAllPalette: }
  Black        = 0;
  Blue         = 1;
  Green        = 2;
  Cyan         = 3;
  Red          = 4;
  Magenta      = 5;
  Brown        = 6;
  LightGray    = 7;
  DarkGray     = 8;
  LightBlue    = 9;
  LightGreen   = 10;
  LightCyan    = 11;
  LightRed     = 12;
  LightMagenta = 13;
  Yellow       = 14;
  White        = 15;

  { Line styles and widths for Get/SetLineStyle: }
  SolidLn    = 0;
  DottedLn   = 1;
  CenterLn   = 2;
  DashedLn   = 3;
  UserBitLn  = 4;       { User-defined line style }


  NormWidth  = 1;
  ThickWidth = 3;

  { Set/GetTextStyle constants: }
  DefaultFont   = 0;    { 8x8 bit mapped font }

  TriplexFont   = 1;    { "Stroked" fonts }
  SmallFont     = 2;
  SansSerifFont = 3;
  GothicFont    = 4;

  HorizDir   = 0;       { left to right }
  VertDir    = 1;       { bottom to top }

  UserCharSize = 0;     { user-defined char size }

  { Clipping constants: }
  ClipOn  = true;
  ClipOff = false;

  { Bar3D constants: }
  TopOn  = true;
  TopOff = false;

  { Fill patterns for Get/SetFillStyle: }
  EmptyFill       = 0;  { fills area in background color }
  SolidFill       = 1;  { fills area in solid fill color }
  LineFill        = 2;  { --- fill }
  LtSlashFill     = 3;  { /// fill }
  SlashFill       = 4;  { /// fill with thick lines }
  BkSlashFill     = 5;  { \\\ fill with thick lines }
  LtBkSlashFill   = 6;  { \\\ fill }
  HatchFill       = 7;  { light hatch fill }
  XHatchFill      = 8;  { heavy cross hatch fill }
  InterleaveFill  = 9;  { interleaving line fill }
  WideDotFill     = 10; { Widely spaced dot fill }
  CloseDotFill    = 11; { Closely spaced dot fill }
  UserFill        = 12; { user defined fill }

  { BitBlt operators for PutImage: }
  NormalPut     = 0;    { MOV }
  XORPut        = 1;    { XOR }
  OrPut         = 2;    { OR  }
  AndPut        = 3;    { AND }
  NotPut        = 4;    { NOT }

  { Horizontal and vertical justification for SetTextJustify: }
  LeftText   = 0;
  CenterText = 1;
  RightText  = 2;

  BottomText = 0;
{ CenterText = 1; already defined above }
  TopText    = 2;


const
  MaxColors = 15;
type
  PaletteType = record
      Size   : byte;
      Colors : array[0..MaxColors] of shortint;
    end;

  LineSettingsType = record
      LineStyle : word;
      Pattern   : word;
      Thickness : word;
    end;

  TextSettingsType = record
      Font      : word;
      Direction : word;
      CharSize  : word;
      Horiz     : word;
      Vert      : word;
    end;

  FillSettingsType = record               { Pre-defined fill style }
      Pattern : word;
      Color   : word;
    end;

  FillPatternType = array[1..8] of byte;  { User defined fill style }

  PointType = record
      X, Y : integer;
    end;

  ViewPortType = record
      x1, y1, x2, y2 : integer;
      Clip           : boolean;
    end;

  ArcCoordsType = record
      X, Y           : integer;
      Xstart, Ystart : integer;
      Xend, Yend     : integer;
    end;

var
  GraphGetMemPtr  : Pointer;   { allows user to steal heap allocation }
  GraphFreeMemPtr : Pointer;   { allows user to steal heap de-allocation }

{ *** high-level error handling *** }
function GraphErrorMsg(ErrorCode : integer) : String;
function GraphResult : integer;

{ *** detection, initialization and crt mode routines *** }
procedure DetectGraph(var GraphDriver, GraphMode : integer);

procedure InitGraph(var GraphDriver : integer;
                    var GraphMode   : integer;
                        PathToDriver : String);

function RegisterBGIfont(font : pointer) : integer;
function RegisterBGIdriver(driver : pointer) : integer;
procedure SetGraphBufSize(BufSize : word);
procedure GetModeRange(GraphDriver : integer; var LoMode, HiMode : integer);
procedure SetGraphMode(Mode : integer);
function GetGraphMode : integer;
procedure GraphDefaults;
procedure RestoreCrtMode;
procedure CloseGraph;

function  GetX : integer;
function  GetY : integer;
function  GetMaxX : integer;
function  GetMaxY : integer;

{ *** Screen, viewport, page routines *** }
procedure ClearDevice;
procedure SetViewPort(x1, y1, x2, y2 : integer; Clip : boolean);
procedure GetViewSettings(var ViewPort : ViewPortType);
procedure ClearViewPort;
procedure SetVisualPage(Page : word);
procedure SetActivePage(Page : word);

{ *** point-oriented routines *** }
procedure PutPixel(X, Y : integer; Pixel : word);
function  GetPixel(X, Y : integer) : word;

{ *** line-oriented routines *** }
procedure LineTo(X, Y : integer);
procedure LineRel(Dx, Dy : integer);
procedure MoveTo(X, Y : integer);
procedure MoveRel(Dx, Dy : integer);
procedure Line(x1, y1, x2, y2 : integer);
procedure GetLineSettings(var LineInfo : LineSettingsType);
procedure SetLineStyle(LineStyle : word;
                       Pattern   : word;
                       Thickness : word);

{ *** polygon, fills and figures *** }
procedure Rectangle(x1, y1, x2, y2 : integer);
procedure Bar(x1, y1, x2, y2 : integer);
procedure Bar3D(x1, y1, x2, y2 : integer; Depth : word; Top : boolean);
procedure DrawPoly(NumPoints : word; var PolyPoints);
procedure FillPoly(NumPoints : word; var PolyPoints);
procedure GetFillSettings(var FillInfo : FillSettingsType);
procedure GetFillPattern(var FillPattern : FillPatternType);
procedure SetFillStyle(Pattern : word; Color : word);
procedure SetFillPattern(Pattern : FillPatternType; Color : word);
procedure FloodFill(X, Y : integer; Border : word);

{ *** arc, circle, and other curves *** }
procedure Arc(X, Y : integer; StAngle, EndAngle, Radius : word);
procedure GetArcCoords(var ArcCoords : ArcCoordsType);
procedure Circle(X, Y : integer; Radius : word);
procedure Ellipse(X, Y : integer;
                  StAngle, EndAngle : word;
                  XRadius, YRadius  : word);
procedure GetAspectRatio(var Xasp, Yasp : word);
procedure PieSlice(X, Y : integer; StAngle, EndAngle, Radius : word);

{ *** color and palette routines *** }
procedure SetBkColor(Color : word);
procedure SetColor(Color : word);
function GetBkColor : word;
function GetColor : word;
procedure SetAllPalette(var Palette);
procedure SetPalette(ColorNum : word; Color : shortint);
procedure GetPalette(var Palette : PaletteType);
function GetMaxColor : word;

{ *** bit-image routines *** }
function  ImageSize(x1, y1, x2, y2 : integer) : word;
procedure GetImage(x1, y1, x2, y2 : integer; var BitMap);
procedure PutImage(X, Y : integer; var BitMap; BitBlt : word);

{ *** text routines *** }
procedure GetTextSettings(var TextInfo : TextSettingsType);
procedure OutText(TextString : string);
procedure OutTextXY(X, Y : integer; TextString : string);
procedure SetTextJustify(Horiz, Vert : word);
procedure SetTextStyle(Font, Direction : word; CharSize : word);
procedure SetUserCharSize(MultX, DivX, MultY, DivY : word);
function  TextHeight(TextString : string) : word;
function  TextWidth(TextString : string) : word;

implementation


======================================================================
                    GRAPH CORRECTIONS & ADDITIONS
======================================================================

This section contains corrections and additions to the Graph unit
material in the manual. Several important changes have been made to
the Graph unit since the manual was printed. These changes fall into
two categories:

  1. Parameter type changes. In an effort to make it easier to
     remember which numeric data types are used in the Graph unit, the
     following conventions are observed:

     o All graphics coordinates are of type integer (even if the manual
       says X,Y : word, for example).
     o All graphics errors are negative numbers (and are therefore
       returned as type integer).
     o The active driver and mode are of type integer (because they
       are used as error returns).
     o Other numeric parameter types are unsigned (type word or byte).

     Refer to beginning of this file for an up-to-date listing of the
     interface section for GRAPH.TPU. Also note that the procedure and
     function reference section available via online help is
     up-to-date (type F1 in the integrated environment).

  2. Several new procedures and functions have been added. These are:

       o GetFillPattern - Returns the last fill pattern set by a call
           to SetFillPattern.

       o GetMaxColor - Returns the highest color that can be passed to
           the SetColor procedure.

       o GetModeRange - Returns the lowest and highest graphics modes
           for a given driver.

       o GraphDefaults - Homes the current pointer (CP) and resets all
           graphics system default values (viewport, palette, styles,
           etc.).

       o RegisterBGIdriver - Registers a user-loaded or linked-in BGI
           driver with the graphics system.

       o RegisterBGIfont - Registers a user-loaded or linked-in BGI
           font with the graphics system.

       o SetGraphBufSize - Allows you to change the size of the buffer
           used for scan and flood fills.

       o SetUserCharSize - Allows the user to vary the character
           width and height for stroked fonts.


Corrections/Additions to the Graphics Documentation
===================================================

CHANGES TO INTRODUCTORY MATERIAL

Current Position                                            P-310, 447
----------------
    The routines in the Graph unit that change the CP are

      **InitGraph, **SetGraphMode, **ClearDevice, **GraphDefaults,
      **ClearViewPort, **SetViewPort, MoveTo, MoveRel, LineTo,
      LineRel, OutText.

    The ** indicates procedures that move the CP to (0,0).

Driver Files
------------
  Graphics drivers can be loaded by InitGraph, or loaded and
  registered by a user program. In addition, you can link a graphics
  driver directly into an .EXE file (see discussion of
  RegisterBGIdriver below). The following drivers are provided:

    CGA.BGI    - driver for IBM CGA, MCGA
    EGAVGA.BGI - driver for IBM EGA, VGA
    HERC.BGI   - driver for Hercules monochrome
    ATT.BGI    - driver for AT&T 6300 (400 line)
    PC3270.BGI - driver for IBM 3270 PC

Toshiba 3100 and AT&T Driver
----------------------------
  The Toshiba 3100 series supports an AT&T-compatible, 640x400 mode.
  The Toshiba does not use the same INT 10 mode setting as the AT&T
  6300, however. To use the ATT.BGI driver on the Toshiba 3100 series,
  make a one-byte patch to the ATT.BGI file at location 655. Change
  the value there (40) to 74 and save the file to disk.

  Here is a list of the exact keystrokes required to make the patch,
  using the DEBUG.COM program that comes with the MS-DOS operating
  system:

    debug att.bgi<Enter>
    e655<Enter>
    74<Enter>
    w<Enter>
    q<Enter>

  This makes it possible for the ATT.BGI driver to run on the Toshiba,
  but it will no longer work on an AT&T 6300 or true compatible (for
  example, the Compaq III). To use the driver with an AT&T 6300 or
  true compatible, reverse the above process and restore location 655
  to its original value (40). You can also copy ATT.BGI from your
  original Turbo Pascal distribution disks.

  Remember that, by default, the Graph unit will select the CGA driver
  for the AT&T 6300 and compatible graphics adapters (Compaq III,
  Toshiba 3100 series, etc.). To use the AT&T driver, override
  autodetection (see P-314).

Font Files                                                       P-311
----------
  Font files can be loaded from disk automatically by the Graph unit
  at runtime (as described), or they can also be linked in or loaded
  by the user program and "registered" with the Graph unit. A special
  utility, BINOBJ.EXE, is provided that converts a font file (or any
  binary data file, for that matter) to an .OBJ file that can be
  linked into a unit or program using the {$L} compiler directive.
  This makes it possible for a program to have all its font files
  built into the .EXE file. Refer to the notes that follow on
  RegisterBGIfont, and read the comments at the beginning of the
  GRLINK.PAS sample program Disk II.

Getting Started                                                  P-314
---------------
  In the second paragraph, it says "Replace lines 8 and 9..." It
  should read "Replace lines 9 and 10..."

User-Written Heap Management Routines                     P-315 to 316
-------------------------------------
  The heap management routines referenced by GraphGetMemPtr and
  GraphFreeMemPtr are called by the Graph unit to allocate and
  deallocate memory for three different purposes:

    o a multi-purpose graphics buffer whose size can be set by a
      call to SetGraphBufSize (default = 4 K)
    o a device driver that is loaded by InitGraph (*.BGI files)
    o a stroked font file that is loaded by SetTextStyle (*.CHR files)

  The graphics buffer is always allocated on the heap. The device
  driver is allocated on the heap unless your program loads or links
  one in and calls RegisterBGIdriver. And the font file is allocated
  on the heap when you select a stroked font using
  SetTextStyle--unless your program loads or links one in and calls
  RegisterBGIfont.

  The last line of non-program text on P-315 should refer to
  "MyExitProc" rather than "Exit." In addition, the Write and
  RestoreCrtMode statements should be removed from the MyGetMem
  and MyFreeMem procedures on P-316.

  The Graph unit installs a HeapError function exactly like the one
  described on P-347, 348 in the manual. Normally, a runtime error
  occurs if there is not enough memory available to meet an allocation
  request by GetMem or New. When using the Graph unit and not enough
  memory is available, a nil pointer will be returned by GetMem or New
  and program execution will continue normally.

Changes to Graph Interface Section                               P-317
----------------------------------
  Several changes have been made to the Graph unit since the
  manual was printed; for an up-to-date listing, please refer to
  the interface documentation at the beginning of this file.

Invalid Settings                    P-471, 475, 476, 479, 480, 483-485
----------------
  If invalid input is passed to any of the following routines,
  GraphResult will return a value of -11 (grError) and no changes will
  be made to the current settings:

    SetAllPalette, SetFillPattern, SetFillStyle, SetLineStyle,
    SetPalette, SetTextJustify, SetTextStyle, SetViewPort

VGA Graphics Modes                                P-318, 419, 435, 478
------------------
  The Graph unit supports 3 VGA modes: VGALo, VGAMed, VGAHi. In
  addition, the VGA graphics adapter supports an MCGA-compatible
  640x480, 2 color mode with 2 palette entries. To use this
  MCGA-compatible mode on a VGA, use the MCGA driver and MCGHi
  mode:

    uses Graph;
    var
      GraphDriver, GraphMode, Err : integer;
    begin
      GraphDriver := MCGA;
      GraphMode := MCGAHi;
      InitGraph(GraphDriver, GraphMode, '');
      if GraphResult < 0 then Halt(1);
      OutText('640x480 mode on a VGA');
      Readln;
      CloseGraph;
    end.


CHANGES TO FUNCTION AND PROCEDURE LOOKUP (CHAPTER 27)

Arc                                                              P-382
---
  A start angle of 0 and an end angle of 360 degrees will draw
  complete figures for PieSlice, Arc, and Ellipse:

    Arc(100, 100, 0, 360, 25);

  Angles are counter-clockwise, with zero degrees at three o'clock.

Bar, Bar3D                                                   P-384,385
----------
  The manual states that an error can occur during a Bar or Bar3D
  call. However, GraphResult is unaffected by a call to either
  routine. In addition, Bar does not outline the bar. To draw an
  outlined bar, call Bar3D with a depth of zero.

ClearDevice                                                      P-311
-----------
  ClearDevice does not reset defaults as indicated in the manual.
  Instead, it clears the entire screen and moves the current pointer
  (CP) to (0,0) in the viewport. To reset the defaults, call
  GraphDefaults after doing a ClearDevice. For more information, refer
  to the notes on GraphDefaults below.

CloseGraph                                                       P-391
----------
  CloseGraph only de-allocates driver and font memory buffers if
  they were allocated by calls to GraphGetMem and GraphFreeMem.
  Drivers or fonts that were registered using RegisterBGIdriver
  or RegisterBGIfont are not de-allocated by CloseGraph.

DetectGraph                                                      P-397
-----------
  In the example program for DetectGraph one of the statements has
  an unnecessary open parentheses; it should read:

      GraphMode := CGAHi;

DrawPoly                                                     P-399,400
--------
  The manual states that an error can occur during a call to DrawPoly.
  However, GraphResult is unaffected by calls to DrawPoly. In
  addition, the last paragraph of the remarks section of DrawPoly
  should read:

    Note that in order to draw a closed figure with N vertices, you
    must pass N + 1 coordinates to DrawPoly, where PolyPoints[1] =
    PolyPoints[N + 1] (see the example on P-400).

  In order to draw a triangle, for example, 4 coordinates must be
  passed to DrawPoly.

  The example on P-400 incorrectly references a type named PolyPoint
  (it should refer to PointType). PointType is declared in the Graph
  unit:

    PointType = record
        X, Y : integer;
      end;

Ellipse                                                          P-400
-------
  A start angle of 0 and an end angle of 360 degrees will draw
  complete figures for PieSlice, Arc, and Ellipse:

    Ellipse(100, 100, 0, 360, 25, 40);

  Angles are counter-clockwise, with zero degrees at three o'clock.

FillPoly                                                         P-407
--------
  FillPoly, unlike DrawPoly, does not require an extra vertex in order
  to draw a closed figure (the 6th point in the Pentagon array is
  unnecessary). FillPoly outlines the polygon, then fills it using a
  scan conversion algorithm. Therefore, the DrawPoly statement at the
  beginning of the sample program is also unnecessary. Note that it is
  possible to draw a polygon without an outline by setting the
  drawcolor to the background color before calling FillPoly:

    SetColor(GetBkColor);     { turn off draw color }
    FillPoly(SomePoly);       { filled polygon with no outline }

FloodFill                                                   P-320, 409
---------
  The FloodFill procedure fills a bounded region using the current
  fill pattern and fill color. As described in the beginning of this
  section, all Graph coordinates are of type integer. The correct
  FloodFill declaration is

    procedure FloodFill(X, Y : integer; Border : word);

  Also note that FloodFill stops after two blank lines have been
  output. This can occur with a sparse fill pattern and a small
  polygon. In the following program, the rectangle is not
  completely filled:

    program StopFill;
    uses Graph;
    var
      Driver, Mode : integer;
    begin
      Driver := Detect;
      InitGraph(Driver, Mode, '');
      if GraphResult <> grOk then
        Halt(1);
      SetFillStyle(LtSlashFill, GetMaxColor);
      Rectangle(0, 0, 8, 20);
      FloodFill(1, 1, GetMaxColor);
      Readln;
      CloseGraph;
    end.

  In this case, using a denser fill pattern like SlashFill will
  completely fill the figure.

  The "See Also" and "Example" sections for the FloodFill procedure
  should be:

    See Also   SetFillStyle, SetFillPattern

    Example    begin
                 ...
                 SetFillStyle(LineFill, Red);
                 FloodFill(50,50,Blue);
                 ...
               end.

GetArcCoords                                                     P-412
------------
  The Graph unit's type declaration for ArcCoordsType is

    type
      ArcCoordsType = record
        X, Y,
        Xstart, Ystart,
        Xend, Yend : integer;
      end;

  The example program for the GetArcCoords procedure should be

    uses Graph;
    var
      ArcCoords : ArcCoordsType;
      begin
        ...
        Arc(100,100,0,89,30);
        GetArcCoords(ArcCoords);
        MoveTo(100,100);
        with ArcCoords do
          Line(Xstart, Ystart, Xend, Yend);
        ...
      end.

GetBkColor                                                       P-413
----------
  The example incorrectly references a variable PaletteSize in the
  while loop on P-414. Here is the correct example:

    uses Crt, Graph;
    var
      GraphDriver, GraphMode : integer;
      Color : word;
      Pal : PaletteType;
    begin
      GraphDriver := Detect;
      InitGraph(GraphDriver, GraphMode, '');
      if GraphResult <> grOk then
        Halt(1);
      Randomize;
      GetPalette(Pal);
      repeat                               { cycle through colors }
        Color := Succ(GetBkColor);
        if Color > Pal.Size - 1 then
          Color := 0;
        SetBkColor(Color);
        LineTo(Random(GetMaxX), Random(GetMaxY));
      until KeyPressed;                    { type ^Break to exit }
      CloseGraph;
    end.

GetFillPattern                                       [ new procedure ]
--------------
  procedure GetFillPattern(var FillPattern : FillPatternType);

    Returns the last fill pattern set by a call to SetFillPattern.
    FillPatternType is declared in the Graph unit:

      type
        FillPatternType = array[1..8] of byte;

    If no user call has been made to SetFillPattern, GetFillPattern
    will return an array filled with $FF.

    Restrictions:  Must be in graphics mode.

GetGraphMode                                                     P-418
------------
  For an up-to-date listing of the constants on this page, refer to
  the interface section at the beginning of this file.

GetImage                                                         P-419
--------
  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct GetImage declaration is

    procedure GetImage(x1, y1, x2, y2 : integer; var BitMap);

GetLineSettings                                                  P-421
---------------
  In the example program, the following should be added to variable
  declaration:

    CurStyle, CurPattern, CurWidth : word;

GetMaxColor                                           [ new function ]
-----------
  function GetMaxColor : word;

    Returns the highest color that can be passed to the SetColor
    procedure. For example, on an 256K EGA, GetMaxColor will
    always return 15, which means that any call to SetColor with a
    value from 0..15 is valid. On a CGA in high-resolution mode or
    on a Hercules monochrome adapter, GetMaxColor returns a value
    of 1, because these adapters only support draw colors of 0 or
    1.

    Restrictions:  Must be in graphics mode.

GetMaxX, GetMaxY                                                 P-421
----------------
  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct GetMaxX, GetMaxY declarations are

    function  GetMaxX : integer;
    function  GetMaxY : integer;

GetModeRange                                         [ new procedure ]
------------
  procedure GetModeRange(GraphDriver : integer;
                  var LoMode, HiMode : integer);

    Returns the lowest and highest valid graphics mode for a given
    driver. The output from the following program:

      uses Graph;
      var
        Lowest, Highest : integer;
      begin
        GetModeRange(EGA64, Lowest, Highest);
        Write('Lowest = ', Lowest);
        Write(' Highest = ', Highest);
      end.

    will be Lowest = 0, Highest = 1.

    If the value of GraphDriver is invalid (legal values are 1..5,
    7..10), the return parameters are set to -1.

GetTextSettings                                                  P-424
---------------
  In the example program at the top of page 425, the following should
  be added to the variable declaration:

    CurFont,
    CurDirection,
    CurSize,
    CurHoriz,
    CurVert : word;

GetViewSettings                                                  P-425
---------------
  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct GetViewSettings declaration is

    procedure GetViewSettings(var ViewPort : ViewPortType);

  and the declaration for ViewPortType is

   ViewPortType = record
      x1, y1, x2, y2 : integer;
      Clip           : boolean;
    end;

GraphDefaults                                        [ new procedure ]
-------------
  procedure GraphDefaults;

    Homes the current pointer (CP) and resets the graphics system
    to the default values for

      o viewport
      o palette
      o draw and background colors
      o line style and line pattern
      o fill style, fill color, and fill pattern
      o active font, text style, text justification, and user char
        size

    Restrictions:  Must be in graphics mode.

GraphResult                                       P-312, 313, 429, 434
-----------
  The following error codes and constants have been added to the Graph
  unit:

    Error                             Graph Unit
     Code    Description                Constant
     ----    -----------                --------
      -11    Graphics error             grError
      -12    Graphics I/O error         grIOError
      -13    Invalid font file          grInvalidFont
      -14    Invalid font number        grInvalidFontNum
      -15    Invalid device number      grInvalidDeviceNum

  Here's an updated list of all the routines that set GraphResult:

    DetectGraph, FillPoly, FloodFill, ImageSize, InitGraph, PieSlice,
    RegisterBGIdriver, RegisterBGIfont, SetAllPalette, SetFillPattern,
    SetFillStyle, SetGraphBufSize, SetGraphMode, SetLineStyle,
    SetPalette, SetTextJustify, SetTextStyle, SetViewPort, ValidMode

ImageSize                                                        P-432
---------
  The memory required to store the image is computed by multiplying
  the width of the region times the height divided by the number of
  pixels per byte. Always use ImageSize to calculate the size of the
  region.

  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct ImageSize declaration is

    function  ImageSize(x1, y1, x2, y2 : integer) : word;

InitGraph                                                   P-434, 435
---------
  Two additional error codes may be returned from a call to InitGraph:

    Error                             Graph Unit
     Code    Description                Constant
     ----    -----------                --------
      -10    Invalid graphics mode      grInvalidMode
             for selected driver
      -15    Invalid device number      grInvalidDeviceNum

  In addition, many of the graphics constants have changed. Refer to
  interface section at the beginning of this file.

LineRel                                                          P-441
-------
  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct LineRec declaration is

    procedure LineRel(Dx, Dy : integer);

OutText, OutTextXY                                          P-451, 452
------------------
  The current pointer (CP) is only updated by OutText if the direction
  is horizontal and the horizontal justification is left. Text output
  direction is set by SetTextStyle (horizontal or vertical), text
  justification is set by SetTextJustify (CP at the left of the
  string, centered around CP, or CP at the right of the string;
  written above CP, below CP, or centered around CP). In the following
  example, Block #1 outputs ABCDEF and moves CP (text is both
  horizontally output and left-justified); Block #2 outputs ABC with
  DEF written right on top of it (because text is right-justified);
  similarly, block #3 outputs ABC with DEF written right on top of it
  (because text is written vertically).

    program CPupdate;
    uses Graph;
    var
      Driver, Mode : integer;
    begin
      Driver := Detect;
      InitGraph(Driver, Mode, '');
      if GraphResult < 0 then
        Halt(1);

      { #1 }
      MoveTo(0, 0);
      SetTextStyle(DefaultFont, HorizDir, 1);    { charsize = 1 }
      SetTextJustify(LeftText, TopText);
      OutText('ABC');                            { CP is updated }
      OutText('DEF');                            { CP is updated }

      { #2 }
      MoveTo(100, 50);
      SetTextStyle(DefaultFont, HorizDir, 1);    { charsize = 1 }
      SetTextJustify(RightText, TopText);
      OutText('ABC');                            { CP is updated }
      OutText('DEF');                            { CP is updated }

      { #3 }
      MoveTo(100, 100);
      SetTextStyle(DefaultFont, VertDir, 1);     { charsize = 1 }
      SetTextJustify(LeftText, TopText);
      OutText('ABC');                            { CP is NOT updated }
      OutText('DEF');                            { CP is NOT updated }

      Readln;
      CloseGraph;
    end.

  The CP is never updated by OutTextXY.

  The default font (8x8 bit-mapped) is not clipped at the screen edge.
  Instead, if any part of the string would go off the screen, no text
  is output. For example, the following statements would have no
  effect:

    SetViewPort(0, 0, GetMaxX, GetMaxY, ClipOn);
    SetTextJustify(LeftText, TopText);
    OutTextXY(-5, 0);                    { -5,0 not on screen }
    OutTextXY(GetMaxX - 1, 0, 'ABC');    { part of 'A', all of
                                           'BC' off screen }

  The "stroked" fonts are clipped at the screen edge, however.

PutImage                                                         P-456
--------
  Note that PutImage is never clipped to the viewport boundary.
  Moreover--with one exception--it is not actually clipped at the
  screen edge either. Instead, if any part of the image would go off
  the screen, no image is output. In the following example, the first
  image would be output, but the middle three PutImage statements
  would have no effect:

    program NoClip;
    uses graph;
    var
      Driver, Mode : integer;
      p : pointer;
    begin
      Driver := Detect;
      InitGraph(Driver, Mode, '');
      if GraphResult < 0 then
        Halt(1);
      SetViewPort(0, 0, GetMaxX, GetMaxY, clipon);
      GetMem(p, ImageSize(0, 0, 99, 49));
      PieSlice(50, 25, 0, 360, 45);
      GetImage(0, 0, 99, 49, p^);      { width = 100, height = 50 }
      ClearDevice;
      PutImage(GetMaxX - 99, 0,        { will barely fit }
               p^, NormalPut);
      PutImage(GetMaxX - 98, 0,        { x + height > GetMaxX }
               p^, NormalPut);
      PutImage(-1, 0,                  { -1,0 not on screen }
                p^, NormalPut);
      PutImage(0, -1,                  { 0,-1 not on screen }
                p^, NormalPut);
      PutImage(0, GetMaxY - 30,        { will output 31 "lines" }
                p^, NormalPut);
      Readln;
      CloseGraph;
    end.

  In the last PutImage statement, the height is clipped at the lower
  screen edge and a partial image is displayed. This is the only time
  any clipping is performed on PutImage output.

  PutImage(x, y, BitMap, NotPut) inverts the bits in BitMap and then
  puts the image stored in BitMap at (x, y) using a machine language
  MOV instruction. Thus the resulting image is the "inverse" of the
  original BitMap.

PieSlice                                                         P-454
--------
  A start angle of 0 and an end angle of 360 degrees will draw
  complete figures for PieSlice, Arc, and Ellipse:

    PieSlice(100, 100, 0, 360, 55);

  Angles are counter-clockwise, with zero degrees at three o'clock.

RegisterBGIfont                                       [ new function ]
---------------
  function RegisterBGIfont(font : pointer) : integer;

    Registers a user-loaded or linked-in BGI font with the graphics
    system. The return value is less than zero if an error occurs,
    otherwise the internal font number is returned. This routine
    enables a user to load a font file and "register" the font by
    passing its memory location to RegisterBGIfont. When that font is
    selected with a call to SetTextStyle, the registered font will be
    used (instead of being loaded from disk by the Graph unit). A
    user-registered font can be loaded from disk onto the heap, or
    converted to an .OBJ file (using BINOBJ.EXE) and linked into the
    .EXE.

    Possible error returns are

        Error  Error
        Code   Identifier        Comments
        ----   ----------        --------
        -11    grError           There is no room in the font table
                                 to register another font. (The
                                 font table holds up to 10 fonts,
                                 and only 4 are provided, so this
                                 error should not occur.)

        -13    grInvalidFont     The font header is not recognized.

        -14    grInvalidFontNum  The font number in the font header
                                 is not recognized.

    The following program loads the triplex font onto the heap,
    registers it with the graphics system, and then alternates
    between using triplex and another stroked font that the Graph
    unit loads from disk (SansSerifFont):

      program LoadFont;
      uses Graph;
      var
        Driver, Mode : integer;
        FontF : file;
        FontP : pointer;
      begin
        { Open font file, read into memory, register it }
        Assign(FontF, 'TRIP.CHR');
        Reset(FontF, 1);
        GetMem(FontP, FileSIze(FontF));
        BlockRead(FontF, FontP^, FileSize(FontF));
        if RegisterBGIfont(FontP) < 0 then
        begin
          Writeln('Error registering font: ',
                  GraphErrorMsg(GraphResult));
          Halt(1);
        end;

        { Init graphics }
        Driver := Detect;
        InitGraph(Driver, Mode, '..\');
        if GraphResult < 0 then
          Halt(1);

        Readln;
        { Select registered font }
        SetTextStyle(TriplexFont, HorizDir, 4);
        OutText('Triplex loaded by user program');
        MoveTo(0, TextHeight('a'));


        Readln;
        { Select font that must be loaded from disk }
        SetTextStyle(SansSerifFont, HorizDir, 4);
        OutText('Your disk should be spinning...');
        MoveTo(0, GetY + TextHeight('a'));

        Readln;
        { Re-select registered font (already in memory) }
        SetTextStyle(TriplexFont, HorizDir, 4);
        OutText('Back to Triplex');
        Readln;
        CloseGraph;
      end.

    The program begins by loading the triplex font file from disk
    and registering it with the Graph unit. Then a call to
    InitGraph is made to initialize the graphics system. Watch the
    disk drive indicator and press <Enter>. Because the triplex font
    is already loaded into memory and registered, the Graph unit
    does not have to load it from disk (and therefore your disk
    drive should not spin). Next, the program will activate the
    sans serif font by loading it from disk (it is unregistered).
    Press <Enter> again and watch the drive spin. Finally, the
    triplex font is selected again. Since it is in memory and
    already registered, the drive will not spin when you press
    <Enter>.

    There are several reasons to load and register font files. The
    Graph unit only keeps one stroked font in memory at a time. If
    you have a program that needs to quickly alternate between
    stroked fonts, you may want to load and register the fonts
    yourself at the beginning of your program. Then the Graph unit
    will not load and unload the fonts each time a call to
    SetTextStyle is made.

    You also may wish to incorporate the font files directly into
    your .EXE file. In this way, the font files that your program
    needs will be built-in, and only the .EXE and driver files will
    be needed in order to run. The process for incorporating a font
    file into your .EXE is straightforward:

      1.  Run BINOBJ on the font file(s)
      2.  Link the resulting .OBJ file(s) into your program
      3.  Register the linked-in font file(s) before calling
          InitGraph

    For a detailed explanation and example of the preceding, refer to
    the comments at the top of the GRLINK.PAS example program on Disk
    III. Documentation on the BINOBJ utility is contained in a file
    named BINOBJ.DOC on Disk II.

    Note that the default (8x8 bit-mapped) font is built into
    GRAPH.TPU and thus is always in memory. Once a stroked font has
    been loaded, your program can alternate between the default
    font and the stroked font without having to re-load either one
    of them.

    It is also possible to register driver files. Refer to the
    description of RegisterBGIdriver that follows.

RegisterBGIdriver                                     [ new function ]
-----------------
  function RegisterBGIdriver(driver : pointer) : integer;

    Registers a user-loaded or linked-in BGI driver with the graphics
    system. If an error occurs, the return value is less than zero,
    otherwise the internal driver number is returned. This routine
    enables a user to load a driver file and "register" the driver by
    passing its memory location to RegisterBGIdriver. When that driver
    is used by InitGraph, the registered driver will be used (instead
    of being loaded from disk by the Graph unit). A user-registered
    driver can be loaded from disk onto the heap, or converted to an
    .OBJ file (using BINOBJ.EXE) and linked into the .EXE.

    Possible error returns are

        Error  Error
        Code   Identifier        Comments
        ----   ----------        --------
          -4   grInvalidDriver   The driver header is not
                                 recognized.

    The following program loads the CGA driver onto the heap,
    registers it with the graphics system, and calls InitGraph:

      program LoadDriv;
      uses Graph;
      var
        Driver, Mode : integer;
        DriverF : file;
        DriverP : pointer;
      begin
        { Open driver file, read into memory, register it }
        Assign(DriverF, 'CGA.BGI');
        Reset(DriverF, 1);
        GetMem(DriverP, FileSize(DriverF));
        BlockRead(DriverF, DriverP^, FileSIze(DriverF));
        if RegisterBGIdriver(DriverP) < 0 then
        begin
          Writeln('Error registering driver: ',
                  GraphErrorMsg(GraphResult));
          Halt(1);
        end;

        { Init graphics }
        Driver := CGA;
        Mode := CGAHi;
        InitGraph(Driver, Mode, '');
        if GraphResult < 0 then
          Halt(1);

        OutText('Driver loaded by user program');
        Readln;
        CloseGraph;
      end.

    The program begins by loading the CGA driver file from disk and
    registering it with the Graph unit. Then a call is made to
    InitGraph to initialize the graphics system. You may wish to
    incorporate one or more driver files directly into your .EXE file.
    In this way, the graphics drivers that your program needs will be
    built-in, and only the .EXE will be needed in order to run. The
    process for incorporating a driver file into your .EXE is
    straightforward:

      1.  Run BINOBJ on the driver file(s)
      2.  Link the resulting .OBJ file(s) into your program
      3.  Register the linked-in driver file(s) before calling
          InitGraph

    For a detailed explanation and example of the preceding, refer to
    the comments at the top of the GRLINK.PAS example program on Disk
    III. Documentation on the BINOBJ utility is contained in a file
    named BINOBJ.DOC on Disk II.

    It is also possible to register font files. Refer to the
    previous description of RegisterBGIfont .


    Restrictions:  Note that the driver must be registered BEFORE
                   the call to InitGraph. If a call is made to
                   RegisterBGIdriver once graphics have been
                   activated, a value of -11 (grError) will be
                   returned.

RestoreCrtMode                                                   P-466
--------------
  In the example program, CurrGraphMode should be initialized to a
  valid EGA mode (for example, EGAHi) before the call to InitGraph.

SetAllPalette                                                    P-471
-------------
  The first sentence of the Remarks section incorrectly
  identifies the palette size as a word. The PaletteType
  declaration at the bottom of the page is correct.

SetBkColor                                                       P-472
----------
  SetBkColor(N) makes the Nth color in the palette the new background
  color. The only exception is SetBkColor(0), which always sets the
  background color to black.

SetFillStyle                                                     P-476
------------
  The default fill pattern is solid, and the default fill color is the
  maximum color in the palette (as returned by function GetMaxColor).

SetGraphBufSize                                      [ new procedure ]
---------------
  procedure SetGraphBufSize(BufSize : word);

    Allows you to change the size of the buffer used for scan
    and flood fills. The internal buffer size is set to BufSize,
    and a buffer is allocated on the heap when a call is made to
    InitGraph.

    The default buffer size is 4K, which is large enough to fill a
    polygon with about 650 vertices. Under rare circumstances,
    enlarging the buffer may be necessary in order to avoid a
    buffer overflow.

    Restrictions:  Note that once a call to InitGraph has been made,
                   calls to SetGraphBufSize are ignored.

SetLineStyle                                                     P-479
------------
  User-defined line patterns are supported via the SetLineStyle
  procedure:

    procedure SetLineStyle(LineStyle : word;
                           Pattern   : word;
                           Thickness : word);

  Here are the constants defined in the Graph unit:

    { Line styles and widths for Get/SetLineStyle: }
    SolidLn    = 0;
    DottedLn   = 1;
    CenterLn   = 2;
    DashedLn   = 3;
    UserBitLn  = 4;       { User-defined line style }

    NormWidth  = 1;
    ThickWidth = 3;

  LineStyle is a value from SolidLn to UserBitLn (0..4), Pattern
  is ignored unless LineStyle = UserBitLn, and Thickness is
  NormWidth or ThickWidth. When LineStyle = UserBitLn, the line
  is output using the 16-bit pattern defined by the Pattern
  parameter. For example, if Pattern = $AAAA, then the 16-bit
  pattern looks like this:

    1010101010101010         { NormWidth }

    1010101010101010         { ThickWidth }
    1010101010101010
    1010101010101010

SetTextStyle                                                P-483, 484
------------
  The CharSize parameter is of type word. Here's the actual
  declaration for SetTextStyle from the Graph unit:

    procedure SetTextStyle(Font, Direction : word; CharSize : word);

  There are also several additional error return values:

    Error                             Graph Unit
     Code    Description                Constant
     ----    -----------                --------
      -12    Graphics I/O error         grIOError
      -13    Invalid font file          grInvalidFont
      -14    Invalid font number        grInvalidFontNum

  The CharSizeType subrange type and the NormSize constant have both
  been removed from the Graph unit. The normal size values for text
  are 1 for the default font and 4 for a stroked font. These are the
  values that should be passed as the CharSize parameter to
  SetTextStyle.

SetUserCharSize                                      [ new procedure ]
---------------
  procedure SetUserCharSize(MultX, DivX, MultY, DivY : byte);

    Allows the user to vary the character width and height for stroked
    fonts. MultX:DivX is the ratio multiplied by the normal width for
    the active font; MultY:DivY is the ratio multiplied by the normal
    height for the active font. In order to make text twice as wide,
    for example, use a MultX value of 2, and set DivX equal to 1 (2
    div 1 = 2). The following program shows how to change the height
    and width of text:

      program CharSize;
      uses Graph;
      var
        Driver, Mode, Err : integer;

      begin
        Driver := Detect;
        InitGraph(Driver, Mode, '');
        Err := GraphResult;
        if Err < 0 then
        begin
          Writeln('Graphics error: ', GraphErrorMsg(Err));
          Halt(1);
        end;

        { Showoff }
        SetTextStyle(TriplexFont, Horizdir, 4);
        OutText('Norm');

        SetUserCharSize(1, 3, 1, 2);
        SetTextStyle(TriplexFont, Horizdir, UserCharSize);
        OutText('Short ');

        SetUserCharSize(3, 1, 1, 1);
        SetTextStyle(TriplexFont, Horizdir, UserCharSize);
        OutText('Wide');

        Readln;
        CloseGraph;
      end.

    Note that SetUserCharSize is called, followed immediately by a
    call to SetTextStyle.

    Restrictions:  Must be in graphics mode.

SetViewPort                                                      P-485
-----------
  As described in the beginning of this section, all Graph coordinates
  are of type integer. The correct SetViewPort declaration is

    procedure SetViewPort(x1, y1, x2, y2 : integer; Clip : boolean);
